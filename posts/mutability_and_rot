<!doctype html><html><head><meta charset="utf-8" /><title>On Link Rot</title><link href="/assets/base.css" rel="stylesheet" /><link href="/assets/layout.css" rel="stylesheet" /><link href="/assets/post.css" rel="stylesheet" /><script src="/assets/pretty_previews.js" type="module" defer></script><script src="/assets/defs.js" type="module" defer></script></head><body><div id="wrapContent"><h1>DRAFT, DO NOT SHARE YET PLEASE, THANK YOU =)</h1><h1 id="mutability_and_rot"><a class="hsection" data-ref="mutability_and_rot" data-hl="true" data-hsection-level="0" href="#mutability_and_rot">Mutability Does Not Imply Link Rot</a></h1><section data-hsection="mutability_and_rot"><p>The web suffers from <a href="https://en.wikipedia.org/wiki/Link_rot">link rot</a>: hyperlinks that were valid upon creation will often point into nothingness after some time has passed. Within the framework of the web, the typical solution is to link to a snapshot of the original page, hosted on <a href="https://archive.org/">archive.org</a>.</p><p>Many projects that envision an alternative to the web try to eliminate the problem of dead links as part of their architecture, usually by employing <a href="https://en.wikipedia.org/wiki/Content-addressable_storage">content-addressing</a> of immutable data. <strong>I propose that link rot and dead links are separate concepts, and eliminating link rot at the cost of eliminating all dead links is not worth it.</strong></p><p>I will speak of link <i>rot</i> when a link becomes unresolvable due to <em>inaction</em> of the content’s author. Passive link rot is deeply built into the web, due to the way domains work: they are only rented, never bought. Renewing a domain requires active action. When an author drifts away from old work, they will eventually stop paying the rent for the domain — and the content goes down.</p><p>Contrast this with active <i>mutation</i>, where an author opts to delete or change some content that is being referenced by other peoples’ links. This kind of link invalidation is a feature, not a bug. It gives agency to authors. In particular, authors can set up <a href="https://en.wikipedia.org/wiki/URL_redirection">URL redirections</a> if they want to move content without making it inaccessible.</p><p>Systems that eliminate <em>all</em> dead links by design <span class="nowrap">solve<span class="sidenoteCounter">1</span></span><span class="marginale"><span class="sidenoteCounter">1</span>Actually, the content you link to still needs to be stored <em>somewhere</em> for it to be resolvable. In principle, any entity that stores a document can also store everything that this document (transitively) links to. <em>Surely</em> that is completely feasible and will never run into any resource limits.</span> the problem of link rot, but they also eliminate mutation. They strip authors of all agency beyond the act of <span class="nowrap">publishing<span class="sidenoteCounter">2</span></span><span class="marginale"><span class="sidenoteCounter">2</span>Publishing something on the web always sacrifices <em>some</em> agency over the data: whoever consumes the data can take a screenshot and put it on their fridge, and no computer protocol will allow the author to remove that printout. But an author always retains control over the default way of accessing the data, which will be followed by the vast majority of future visitors.</span>. I, personally, am not interested in developing or using systems that strip humans of agency by design.</p><p><strong>It is possible to design systems that allow for active mutation but do not suffer from passive link rot.</strong> To see how, it helps to take a step back and consider the problem space.</p><h2 id="mutability_and_rot_problem_space"><a class="hsection" data-ref="mutability_and_rot_problem_space" data-hl="true" data-hsection-level="1" href="#mutability_and_rot_problem_space"> Data, Mutability, and Naming</a></h2><section data-hsection="mutability_and_rot_problem_space"><p>All data is immutable. You cannot <em>change</em> the string <code>"Hello World!"</code>, just like you cannot change the number 17. Neither can you change the source code of this website, it just <em>is</em>. When we talk about mutability in computer science, we mean something else: we map some identifier to some data, and later, we might map the same identifier to different data. The variable <code>my_favourite_string</code> might first be mapped to <code>"Hello World!"</code>, and later to <code>"I love you"</code>. On the web, URLs take on the role of these names.</p><p>Many programming languages offer immutable bindings from names to values: you give a name to some expression, and you are not allowed to reassign that name to any other expression. As a consequence, you can now use the name and the expression interchangeably. There are computational benefits compared to simply copy-pasting the same expression over and over: it suffices to evaluate the expression only once and to then reuse the result; this also shortens the program. But semantically, there is no difference.</p><p>Content-addressing implements the exact same concept: referencing some data by its name is convenient and efficient, but names are ultimately transparent to the meaning of the data. The notion of deleting data that somebody else is referencing makes little sense; if the other person had copied your data verbatim into their own data, you would not expect to be able to selectively delete those sections either.</p><p>The hyperlinks of the web, in contrast, implement <em>mutable</em> mappings. Clicking on a link on different days can yield different results. The underlying technique is that of using <em>addresses</em> as names.<span class="marginale">I am simplifying things on multiple fronts here. But the core argument does not hinge on the simplifications.</span> The link contains a domain, and that domain is translated into an <a href="https://en.wikipedia.org/wiki/IP_address">IP address</a>, which is a (more or less) physical location. At different points in physical time, different data might be placed at that location. This is a simple and efficient form of implementing mutable bindings — variables and pointers in imperative programming languages typically also work this way. Name resolution based in physical addresses is the first source of link rot: somebody needs to maintain the machine that answers HTTP requests.</p><p>On top of this mechanism, the web layers a second step of name resolution: the <a href="https://en.wikipedia.org/wiki/Domain_Name_System">DNS</a><span class="marginale">Technically, this step introduces a second way in which the web enables mutability: the same domain name can point to different IP addresses over time. Since that is a rather unidiomatic approach to changing content, I will mostly ignore this feature.</span> maps human-readable domain names to the IP addresses that make everything work under the hood. Domain names are a scarce resource, so they typically are rented out on a yearly basis. Tying name resolution to continuous payments is the biggest source of link rot, it ensures that content will certainly get lost once its author stops caring about it.</p><p>While immutable name bindings are the easiest solution to link rot, they are not the only solution. Abstractly speaking, the challenge is to find implementation techniques for mutable name bindings not based in locations nor depend on the leasing of scarce resources. This is the solution space with the potential to preserve author agency while not suffering from name rot.</p></section><h2 id="mutability_and_rot_a_solution"><a class="hsection" data-ref="mutability_and_rot_a_solution" data-hl="true" data-hsection-level="1" href="#mutability_and_rot_a_solution"> A Possible Solution</a></h2><section data-hsection="mutability_and_rot_a_solution"><p>One approach to mutable name bindings can be implemented via <a href="https://en.wikipedia.org/wiki/Digital_signature">digital signatures</a>. An author — identified by some public key — binds a name to some data by signing an identifier, a timestamp, and the data <span class="nowrap">itself<span class="sidenoteCounter">3</span></span><span class="marginale"><span class="sidenoteCounter">3</span>A straight-forward optimisation is to sign a secure hash of the data instead.</span>. When the same author binds different data to the same identifier, the binding with the greater timestamp wins. Such a system effectively creates a separate namespace per public key: a <i>name</i> consists of a public key together with an identifier.</p><p>I use <i>timestamp</i> in a wide sense here: a timestamp could be a wall-clock time, or a logical counter, or something else entirely. For example, you could use a secure hash of the previous binding of that name, to establish a cryptographically verifiable order. And once you go here, you might as well use something <a href="https://worm-blossom.github.io/reed/">more efficient</a>. Anything that allows for a deterministic choice between competing bindings goes.</p><p>Note that such a name — unlike a physical address — contains no information on how to resolve it to the underlying data. Neither does a hash in content-addressed systems. Both kinds of systems admit the same classes of solutions, for example to query peers with shared <span class="nowrap">interests<span class="sidenoteCounter">4</span></span><span class="marginale"><span class="sidenoteCounter">4</span>Whether they share those interest naturally or you pay them to care makes little difference on the purely technical level.</span>, or a <a href="https://en.wikipedia.org/wiki/Distributed_hash_table">distributed hash table</a> which randomly assigns storage responsibilities and routes requests accordingly. Over time, lack of interest in some data might mean that you cannot find anyone who stores it. But the name binding itself never rots away.</p><p>Signed bindings like this can hence act as alternatives to location-based addressing or content-adddressing. However, just like an IP address or a hash, the names are not fully meaningful to humans,<span class="marginale">Oligatory reference to <a href="https://en.wikipedia.org/wiki/Zooko%27s_triangle">Zooko’s Triangle</a>.</span>since part of the name is a public key. But the DNS is not the only possible solution to mapping meaningful identifiers to machine-friendly names. A good alternative that does not suffer from link rot would be <a href="https://www.inkandswitch.com/backchannel/">petname systems</a>, for example.</p><p>Is name-resolution that is not based on address resolution and that relies on petnames for usability good enough? I believe and hope so, but I cannot know. But I do know that systems based on content-addressing have to overcome these exact same challenges, just like systems based on signed bindings. Yet the bigger projects in the p2p revival of the 2010s — Secure Scuttlebutt, Dat, IPFS, Holochain come to my mind — exclusively focussed on immutable data. A casual observer of the space might conclude that content-addressing is the only solution to link rot. I hope I have argued convincingly enough that that is not the case.</p></section><h2 id="mutability_and_rot_closing"><a class="hsection" data-ref="mutability_and_rot_closing" data-hl="true" data-hsection-level="1" href="#mutability_and_rot_closing"> Closing Thoughts</a></h2><section data-hsection="mutability_and_rot_closing"><p>Many proposals to make the fediverse less reliant on the continued well-being of individual instances point to content-addressing as the solution. Signed bindings are just as location-independent, yet do not need to give up on mutability. I would love to see more awareness of such alternatives in this space.</p><p>It seems rather unlikely that signed bindings are the <em>only</em> approach to mutability that does not suffer form link rot. I am looking forward to seeing fresh projects pop up that explore other such approaches in the future.</p></section></section></div></body></html>