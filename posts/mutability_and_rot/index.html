<!doctype html><html><head><meta charset="utf-8" /><title>On Link Rot</title><link href="/assets/base.css" rel="stylesheet" /><link href="/assets/layout.css" rel="stylesheet" /><link href="/assets/post.css" rel="stylesheet" /><script src="/assets/pretty_previews.js" type="module" defer></script><script src="/assets/defs.js" type="module" defer></script></head><body><div id="wrapContent"><h1 id="mutability_and_rot"><a class="hsection" data-ref="mutability_and_rot" data-hl="true" data-hsection-level="0" href="#mutability_and_rot">Distributed Mutability Without Link Rot</a></h1><section data-hsection="mutability_and_rot"><p>The web suffers from <a href="https://en.wikipedia.org/wiki/Link_rot">link rot</a>: hyperlinks that were valid upon creation will often point into nothingness after some time has passed. Within the framework of the web, the typical solution is to link to a snapshot of the original page, hosted on <a href="https://archive.org/">archive.org</a>.</p><p>This is not a <em>true</em> solution, however, since a link to the internet archive can rot just like any other link. The archivists best intentions do not protect against <a href="https://blog.archive.org/2024/10/21/internet-archive-services-update-2024-10-21/">targeted attacks to bring down their servers</a>.</p><p>The only foolproof solution is to forego hyperlinks to other servers, and to instead <span class="nowrap">copy<span class="sidenoteCounter">1</span></span><span class="marginale"><span class="sidenoteCounter">1</span>I deliberately ignore dynamically generated content. I wish to discuss interlinked data evolving over time, not computation-as-a-service.</span>  their data onto your own server. The obvious inefficiencies — especially once everyone does this and copying some site would involve recursively copying everything that <em>it</em> had previously copied — can be neatly solved by employing <a href="https://en.wikipedia.org/wiki/Content-addressable_storage">content-addressing</a>: you link to some data by giving its <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">secure hash</a>, and the software transparently fetches, caches, and deduplicates the data. This is essentially the pitch of the <a href="https://en.wikipedia.org/wiki/InterPlanetary_File_System">IPFS</a>.</p><p>But if sufficiently efficient verbatim inclusion of data became <em>the</em>  core mechanism for hyperlinking, something would be lost. When I link to <a href="https://gwil.garden/">a friend’s website</a>, I know that readers will always get the up-to-date version. With a snapshot, the majority of readers would get a stale and incomplete version.</p><p>Personal websites, blogs and microblogs, forums, and the connections between all of these — indeed most facets of the web that make it feel worthwhile, alive, and human to me — rely on content changing over time. Whenever a project promises to deliver “the immutable web”, I internally replace those words with “censorship-resistant collections of data sets”. Those are worthwhile engineering feats in their own, but they serve different needs than the web.</p><p>A quick look at the current landscape of popular distributed systems can make this look like a dilemma: systems which introduce mutability seem to invariably be plagued by link rot. It can feel like either you embrace active mutability at the cost of passive link rot,<span class="marginale">Active mutation might invalidate links when the author deliberately removes a page, but I do not consider this link rot. Link rot stems from inaction, not from delibarately exercised agency. The latter I consider a feature, not a bug.</span> or you eliminate passive link rot at the cost of active mutability.</p><p>That would be a wrong conclusion, there do exist well-known techniques that allow for productive mutability without suffering from link rot. In this post, I want to provide a brief overview of the problem space, to serve as a foundation for future system designs.</p><h2 id="mutability_and_rot_immutable_names"><a class="hsection" data-ref="mutability_and_rot_immutable_names" data-hl="true" data-hsection-level="1" href="#mutability_and_rot_immutable_names"> Names and (Im)mutability</a></h2><section data-hsection="mutability_and_rot_immutable_names"><p>Data is, by definition, immutable. You cannot <em>change</em> the string <code>"Hello World!"</code>, just like you cannot change the number 17. Neither can you change the source code of this website, it just <em>is</em>. When we talk about mutability in computer science, we mean something else: we map some identifier (a <i>name</i>) to some data, and later, we can map the same identifier to different data. The variable <code>my_favourite_string</code> might first be mapped to <code>"Hello World!"</code>, and later to <code>"I love you"</code>. On the web, <a href="https://en.wikipedia.org/wiki/URL">URLs</a> take on the role of these names.</p><p>In programming, the simplemost case of names ist not used for mutability, but merely to make working with large values (or the results of complex computations) easier. Many programming languages offer deliberately <em>immutable</em> bindings from names to values: you give a name to some expression, and you are not allowed to reassign that name to any other expression. As a consequence, you can now use the name and the expression <span class="nowrap">interchangeably<span class="sidenoteCounter">2</span></span><span class="marginale"><span class="sidenoteCounter">2</span>Repeatedly replacing all occurrences of a name with the data to which it was bound is the <a href="https://en.wikipedia.org/wiki/Lambda_calculus#Substitution">core operation</a> of the <a href="https://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</a>, one of the oldest formal models of computation.</span>. There are computational and notational benefits compared to copy-pasting the same complex expressions over and over: it suffices to evaluate the expression only once and to then reuse the result; and programs become shorter. But semantically, there is no difference.</p><p>Content-addressing implements an analogous concept: referencing some data by its name (i.e., its secure hash) is convenient and efficient, but otherwise semantically equivalent to supplying a verbatim copy of the referenced data. The notion of deleting data that somebody else is referencing makes little sense; if the other person had copied your data verbatim into their own data, you would not expect to be able to selectively delete those sections either. Another obvious technical limitation is the impossibility of cyclic <span class="nowrap">references<span class="sidenoteCounter">3</span></span><span class="marginale"><span class="sidenoteCounter">3</span>A challenge to the programming language theory enthusiasts: it seems fair to draw a parallel between cyclic immutable references and mutually recursive functions. The lambda calculus does not look like it would support recursion, let alone mutual recursion, but along come <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator">fixpoint combinators</a> and suddenly you get surprisingly close. What is an analogous concept for cyclic references in content-addressed hypertext systems?</span>.</p></section><h2 id="mutability_and_rot_web"><a class="hsection" data-ref="mutability_and_rot_web" data-hl="true" data-hsection-level="1" href="#mutability_and_rot_web"> Names on the Web</a></h2><section data-hsection="mutability_and_rot_web"><p>The hyperlinks of the web, in contrast, implement <em>mutable</em> mappings — clicking on the same link on different days can yield different results. The process from clicking a link to obtaining the data is quite involved, but for this discussion we can simplify it down to two separate steps: first, a URL is resolved into an <a href="https://en.wikipedia.org/wiki/IP_address">IP address</a>, and second, the <a href="https://en.wikipedia.org/wiki/Web_server">server</a> running at that address is contacted and asked for its data.</p><p>Translation of a URL into an IP address — performed by the <a href="https://en.wikipedia.org/wiki/Domain_Name_System">Domain Name System (DNS)</a> — <span class="nowrap">primarily<span class="sidenoteCounter">4</span></span><span class="marginale"><span class="sidenoteCounter">4</span>Technically, the DNS can also be used to implement mutability, by over time mapping the same URL to different IP addresses serving different content. Using this mechanism for updating content is so unidiomatic that I will disregard it.<br />The DNS can also be used for optimisations like mapping the same URL to different IP addresses serving identical data, based on physical proximity to the requestor. These optimisations do not meaningfully change the conceptual model, so I abstract over them.</span> serves to make the names of the web human-friendly. Working with <code>2001:df2:e500:ed1a::1</code> is a lot less convenient than working with <code>wikipedia.org</code>.</p><p>Unfortunately, human-readable names are a scarce and quite valuable resource. The DNS rents out names on a per-year basis. If you stop paying, all links to your site will stop working. This all but guarantees link rot! From this, we can derive several necessary conditions for avoiding link rot:<span class="marginale">Petname systems make for an example of how to introduce human-friendly names without inducing link rot. A <i>petname</i>, to sketch a rough definition, is any name that a user actively assigns for their own use — think the name you give to a contact on your phone. Petnames are inherently subjective, though their assignment could in principle be delegated instead of being carried out manually.<br /> See also: <a href="https://en.wikipedia.org/wiki/Zooko%27s_triangle">Zooko’s Triangle</a>.</span></p><ul><li>Do not rent out names.</li><li>Do not make name resolution dependent on scarce resources.</li><li>Do not tie name resolution to real-world time.</li></ul><p>After the DNS has resolved a URL into an IP address, the second phase of name resolution on the web takes place: the user agent contacts the server at the given IP address, and the server returns the data it stores at that point in time. This is the primary mechanism for mutability on the web: the same server can store and return different data at different points in time.</p><p>This location-based mutability is analogous to imperative programming: a variable name compiles down to a physical memory address on a computer. Whenever a program access the value of a variable, the computer supplies the current value stored at the corresponding address.</p><p>In a distributed system, location-based name resolution inherently leads to link rot.<span class="marginale">Like the web, the <a href="https://en.wikipedia.org/wiki/Fediverse">Fediverse</a> runs on location-based mutability (as well as DNS). I will be sad to watch large parts of it be swallowed by link rot over the next decades.</span> The server running at the location needs constant attention (or, at the very least, power), or it will be unable to supply data. Attackers or accidents might shut down the server. And censorship could prevent communication with the server.</p></section><h2 id="mutability_and_rot_signed_bindings"><a class="hsection" data-ref="mutability_and_rot_signed_bindings" data-hl="true" data-hsection-level="1" href="#mutability_and_rot_signed_bindings"> Signed Bindings</a></h2><section data-hsection="mutability_and_rot_signed_bindings"><p>A different approach to name-based mutability is what I will <span class="nowrap">call<span class="sidenoteCounter">5</span></span><span class="marginale"><span class="sidenoteCounter">5</span>I personally have first encountered this technique in <a href="https://scuttlebutt.nz/">Secure Scuttlebutt</a> and <a href="https://earthstar-project.org/">Earthstar</a>; the <a href="https://specs.ipfs.tech/ipns/ipns-record/">IPNS</a> cites the <a href="https://en.wikipedia.org/wiki/Self-certifying_File_System">Self-certifying File System</a> as inspiration. It seems safe to say that this technique has been and will be reinvented several times, but I am not aware of a common name for it. So I am giving it one simply to make writing this post more convenient.</span> <i>signed bindings</i>. A name is simply the public key of a <a href="https://en.wikipedia.org/wiki/Digital_signature">digital signature scheme</a>. An author binds data to the name by signing the concatenation of the <span class="nowrap">data<span class="sidenoteCounter">6</span></span><span class="marginale"><span class="sidenoteCounter">6</span>A straightforward optimisation is to sign a secure hash of the data instead.</span> and a timestamp. When the same author binds different data to the same identifier, the binding with the greater timestamp wins. Services that provide name resolution cannot present fraudulent data, because they cannot forge the signature that the requestor will verify. The worst they can do is to deliberately present outdated data — but <em>no</em> system can force other actors to always divulge (new) data anyway.</p><p>I use <i>timestamp</i> in a wide sense here, anything that allows for tie-breaking between competing bindings works. A non-exhaustive selection of choices:</p><ul><li>A wall-clock timestamp (<a href="https://earthstar-project.org/">Earthstar</a>).</li><li>A logical counter (<a href="https://specs.ipfs.tech/ipns/ipns-record/">IPNS</a>).<span class="marginale">The IPNS gives bindings a time-to-live, and the default resolution substrate limits it to 48 hours. This engineering concession sadly results in aggressive link rot.</span></li><li>A secure hash of the previous binding (<a href="https://scuttlebutt.nz/">Secure Scuttlebutt</a>).</li><li>A secure hash of two previous bindings (<a href="https://worm-blossom.github.io/reed/">Reed</a>).</li><li>A secure hash of a block in a blockchain.</li><li>A date on which you placed a secure hash of the data as an advertisement in the <a href="https://en.wikipedia.org/wiki/The_New_York_Times">New York Times</a>.</li></ul><p>The choice of timestamps can have far-reaching consequences. Of particular interest are single-writer versus multi-writer properties. With wall-clock timestamps,<span class="marginale">We have a discussion of the consequences of using claimed wallclock timestamps on the <a href="https://willowprotocol.org/more/timestamps-really/index.html">Willow page</a>.</span> multiple devices can publish data without needing significant coordination (beyond keeping their clocks in rough sync). With logical counters, when two devices publish new data logically concurrently, tiebreaking is needed, and that tiebreaking probably does not always align with user intuition about the passage of physical time. Timestamps based on hash chains enforces mutually exclusive write access to publish updates — concurrent writes can be detected, and typically <a href="https://arxiv.org/pdf/2307.08381">invalidate</a> the name.</p><p>Beyond implying <span class="nowrap">single-writer<span class="sidenoteCounter">7</span></span><span class="marginale"><span class="sidenoteCounter">7</span>Running a distributed mutual-exclusion protocol to manage multiple writers on different physical devices essentially converts them into a single logical writer.</span> systems, another important facet of hash chains is that they only allow for non-destructive mutation. Given that inclusion of a secure hash is semantically equivalent to including the hashed data verbatim, such name bindings only ever append new data, while keeping around all old data.</p><p>Other properties of signed bindings do not depend on the specific choice of timestamps. A fundamental one is that names do not include any information on how to resolve them — in contrast to an address, which essentially <em>is</em> the relevant information on how to resolve it. Systems built on signed bindings need to provide infrastructure for name resolution,<span class="marginale">I drafted quite a few paragraphs of detailed discussion, before deciding this should be left out of scope of this post.</span> such as <a href="https://en.wikipedia.org/wiki/Distributed_hash_table">distributed hash tables (DHTs)</a> or <a href="https://en.wikipedia.org/wiki/Gossip_protocol">gossip protocols</a>.</p><p>Resilient name resolution of signed bindings always builds on the fact that data need not be served by the original author: everyone can verify the signature for the bound data, so there is no need to trust the peer who gives you the data. Introducing intermediaries does open up questions of freshness. Did you get up-to-date data bound to the name, or is the data stale? <span class="nowrap">Typically<span class="sidenoteCounter">8</span></span><span class="marginale"><span class="sidenoteCounter">8</span>A prominent exception is <a href="https://en.wikipedia.org/wiki/Nostr">Nostr</a>, which does not even guarantee <em>eventual</em> consistency.</span>, systems aim for eventual consistency, where all peers will eventually obtain the most up-to-date data once updates stop and the system keeps running long enough.</p><p>While resolving an address and contacting a server directly may feel like a stronger guarantee of recency, you can never know whether the server did not happen to update its data immediately after serving your request.<span class="marginale">The naming model I discuss in this post is purely pull-based. Efficient systems should probably incorporate push-based solutions (subscriptions to binding updates) as well.</span> So you cannot ever be certain to be fully up-to-date in address-based settings either. And with enough engineering effort, you can reduce the delay in name resolution in signed-binding systems quite far as well. In particular, you could annotate names with the (IP) address of a recommended data source to contact for resolution.<span class="marginale">More broadly speaking, there is always an engineering space where you can overlay centralised architectures over a decentralised system to achieve certain optimisations. The important part is to make absolutely sure that things will continue to work when the centralised components fail.</span> Such a system would have all the advantages of regular address-based systems while the recommended server is online, and would fail gracefully to a slower but more resilient resolution mechanism to prevent link rot.</p><p>When everyone can serve data to everyone else, the responsibility for keeping data around is diluted. In this sense, no system can fully prevent link rot: when the last remaining copy of some data is lost, it cannot be retrieved any longer. But, conceptually, each <em>binding</em> itself lasts as long as its digital signature scheme remains secure.</p><p><span class="marginale">For every proposal to add content-addressing to the Fediverse to move beyond reliance on individual instances (i.e., addressed locations), there could be an equivalent proposal championing signed bindings.</span>Perhaps curiously, signed bindings share much the same challenges as systems based on content-addressing. Both deal in names that are not human-readable, and both deal in names that carry no information in how to resolve them. I find it fair to say that <em>if</em> content-addressed systems can be made to work at <span class="nowrap">scale<span class="sidenoteCounter">9</span></span><span class="marginale"><span class="sidenoteCounter">9</span>Did you know that “a dominant global system used by pretty much everyone, their dog, and their dog’s dozens of <a href="https://en.wikipedia.org/wiki/Internet_of_things">IoT</a> devices” is not the only scale worth running systems at?</span>, so can systems based on signed bindings.</p><p>There is a lot more design space for naming systems which enable mutation. Some examples:</p><ul><li>Who should get to resolve names? Can everyone resolve everything, or is it possible to introduce some level of access control?</li><li>Should names carry additional structure? <a href="https://willowprotocol.org/">Willow</a>,<span class="marginale">Willow can also mediate access control via this structure.</span> for example, arranges names in a three-dimensional space, and then allows for spatial queries to resolve names in bulk.</li><li>Are there decentralised, rot-resistant techniques beyond signed bindings?</li></ul><p>For now, I hope to have provided a useful overview of the basics.</p></section><h2 id="mutability_and_rot_important"><a class="hsection" data-ref="mutability_and_rot_important" data-hl="true" data-hsection-level="1" href="#mutability_and_rot_important"> The Actually Important Questions</a></h2><section data-hsection="mutability_and_rot_important"></section><p><span class="marginale">I am channeling <a href="https://en.wikipedia.org/wiki/Joseph_Weizenbaum">Joseph Weizenbaum</a> in his radiant <a data-ref="computer_power_and_human_reason" data-hl="true" href="/treasures/index.html#computer_power_and_human_reason">Computer Power and Human Reason</a> here.</span><span class="marginale">I am also channeling <a href="https://shiba.computer/">Cade Diehm</a>, whose writing has influenced how I approach systems design and who gave me immensely helpful feedback on an early draft of this post.</span>The previous sections were purely technical, they discussed what <em>can</em> be done. Much more important, though, is what <em>should</em> be done. I personally believe strongly that we need resilient systems that do not suffer from link rot yet allow for active mutation. And I am unhappy how much of the time, energy, and resources that go into research and development of resilient systems go into systems with no or purely non-destructive notions of mutability.</p><p>Immutable systems based on content-addressable storage are elegant solutions to important concerns: censorship-resistant<span class="marginale">In my following arguments in favour of mutable names, it is crucial that mutable approaches need not suffer from passive link rot either — otherwise, their benefits would be counteracted by lack of durability and resilience, and we would end up comparing apples and oranges.</span> access to information, automatic durable archiving of valuable material, compression of data (deduplication is a special form of compression).</p><p>As such, I do hope that content-addressing will be an important tool in the distributed information systems of the future. But I believe that content-addressing should not be made the defining feature of such systems. I want to argue that a society would be impoverished<span class="marginale">I fully subscribe to the assumption that <a href="https://en.wikipedia.org/wiki/The_medium_is_the_message">the medium is the message</a>.</span> by making immutable links the default way of connecting its artifacts.</p><p><span class="marginale">Publishing always sacrifices <em>some</em> agency over the data: whoever consumes the data can take a screenshot and put it on their fridge, and no computer protocol will allow the author to remove that printout. But a mutable link lets the author retain control over the outcome of the intended way of accessing the data.</span>When I publish a <em>mutable</em> link to some data, I give agency to the author of that data. They are free to change the contents in the future, or even to fully remove the data. Like a verbatim copy, an <em>immutable</em> link would not award this agency.</p><p>By granting this agency, I voluntarily cede control. The quality of my work will vary based on the future actions of another human. A web of mutable references is a web of human interdepence, and builds on the voluntary giving of trust.</p><p>Freely given trust and consensual interdependence are deeply human, they sit at the root of the most positive relationships we can form. I want to immerse myself (and have others immerse themselves) in a medium that fosters these notions, and I want to stay clear from media whose design choices eliminate them.</p><p>A medium of mutable links should further teach an important lesson: trust must never be without alternative. I <em>can</em> choose to <span class="nowrap">copy<span class="sidenoteCounter">10</span></span><span class="marginale"><span class="sidenoteCounter">10</span>Or, ideally, I would be able to refer to the content via content-addressing, which has much better usability.</span> content and retain full control over it. If trust is not an active choice but the only option, it becomes meaningless.</p><p>I imagine that the vocal proponents of eliminating as much trust from distributed systems as possible arrive at this decision because they primarily reflect on involuntarily given <span class="nowrap">trust<span class="sidenoteCounter">11</span></span><span class="marginale"><span class="sidenoteCounter">11</span>An prime example would be the forced trust in and usage of the currency of the nation state you happen live in — it certainly is no coincidence that cryptocurrency, blockchain, and code-is-law enthusiasts frequently employ narratives of trustlessness.</span>. Such indiscriminate opposition to <em>all</em> (giving of) trust makes me quite sad. Instead, I want to see systems that minimise involuntary, coerced trust, while simultaneously maximising opportunities for voluntarily granting trust.</p><p>And that is why I, like anybody would, decided to write a post on mutable name bindings.</p><p>The analysis of the implications of mutability without link rot is multifaceted. I personally am passionate about the <span class="nowrap">beauty<span class="sidenoteCounter">12</span></span><span class="marginale"><span class="sidenoteCounter">12</span>Let alone the engineering opportunities you get from trusting other agents in a distributed system. But that is a different topic for a different piece of writing.</span> of meaningfully given trust, so that is what I want to contribute here the most. But there are numerous other important issues as well, and things are rarely black and white. The inability to retract one’s material can <a href="https://newdesigncongress.org/en/pub/this-is-fine/">cause harm</a>. But deletion of publicly valuable information can <em>also</em> <a href="https://www.bbc.com/news/articles/cgkj8gx1vy6o">cause harm</a>. Sometimes, active moderation of content by parties other than the authors could <a href="https://erinkissane.com/meta-in-myanmar-full-series">prevent harm</a>. Immutability can support accountability, can counteract gaslighting or the rewriting of alternate facts into the past. How do we deal with lies and manipulation? What are the roles of apologies and foregiveness?</p><p>I do not have all the answers, and neither does anyone else. But we should normalise discussions on these issues. Distributed systems designs are not <span class="nowrap">neutral<span class="sidenoteCounter">13</span></span><span class="marginale"><span class="sidenoteCounter">13</span>And I <em>wish</em> the academic computer science community would stop pretending otherwise.</span>, neither politically nor socially. When I see a new project pop up that glosses over all of these issues and does not position itself, I am not interested. I care less for what you can do, and more for what you consider worth doing.</p><p>I believe that systems which neither suffer from link rot nor force permanence on all participants, which stay resilient yet allow for mutation, should receive more attention. How widely can they be deployed? How accessible can they be, and to whom? How can we categorise different offshoots, how can we explore, chart, and analyse the design space? Which patterns and actors will emerge, who can, should, and will shape these systems? How can we ensure that as many people as possible who wish to engage with them can benefit?</p><p>I believe more people should work toward finding the answers.</p></section><p id="home"><a href="/#other">Home</a></p></div></body></html>