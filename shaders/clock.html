<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8></head>
<style>
  * { margin: 0; padding:0; }

  /* https://stackoverflow.com/a/25842259 */
  body, #glCanvas {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  body {
    min-height: 100vh;
    background-color: black;
  }

  #glCanvas {
    width: 100vw;
    height: 100vh;
  }
</style>
<body>
<canvas id="glCanvas"></canvas>
</body>
<script>
const vertexShaderSource = `#version 300 es
in vec4 a_position;
out vec4 ts;

void main() {
  ts = a_position;
  gl_Position = a_position;
}
`;

const fragmentShaderSource = `#version 300 es

#define PI 3.141592653589793
#define TAU 6.283185307179586
#define PIH 1.5707963267948966

precision mediump float;
out vec4 outColor;
uniform float u_time;
uniform vec2 u_resolution;
uniform float u_h_pct;
uniform float u_m_pct;
uniform float u_s_pct;
uniform float u_rings;

in vec4 ts;

vec2 only_work_with_central_square(vec2 st) {
  if (u_resolution.x >= u_resolution.y) {
        float aspect_ratio = u_resolution.y / u_resolution.x;
        if (st.x < -aspect_ratio) {
            st.x = -1.0;
        } else if (st.x > aspect_ratio) {
            st.x = 1.0;
        } else {
            st.x = st.x * u_resolution.x / u_resolution.y;
        }
    } else {
        float aspect_ratio = u_resolution.x / u_resolution.y;
        if (st.y < -aspect_ratio) {
            st.y = -1.0;
        } else if (st.y > aspect_ratio) {
            st.y = 1.0;
        } else {
            st.y = st.y * u_resolution.y / u_resolution.x;
        }
    }

  return st;
}
  
  // Takes normalized coordinates between -1.0 and 1.0 and returns the distance to the center
  // of the screen and the degree between the coordinate and the center of
  // the screen.
  vec2 d_and_theta(vec2 st) {
      float d = length(st);
      float theta = atan(st.y,st.x);
      return vec2(d, theta);
  }

  mat2 rotate2d(float _angle){
        return mat2(cos(_angle),-sin(_angle),
                    sin(_angle),cos(_angle));
    }

// https://www.shadertoy.com/view/4dKcWK
const float EPSILON = 1e-10;

vec3 HUEtoRGB(in float hue)
{
    // Hue [0..1] to RGB [0..1]
    // See http://www.chilliant.com/rgb2hsv.html
    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);
    return clamp(rgb, 0., 1.);
}

vec3 RGBtoHCV(in vec3 rgb)
{
    // RGB [0..1] to Hue-Chroma-Value [0..1]
    // Based on work by Sam Hocevar and Emil Persson
    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1., 2. / 3.) : vec4(rgb.gb, 0., -1. / 3.);
    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);
    float c = q.x - min(q.w, q.y);
    float h = abs((q.w - q.y) / (6. * c + EPSILON) + q.z);
    return vec3(h, c, q.x);
}

vec3 HSVtoRGB(in vec3 hsv)
{
    // Hue-Saturation-Value [0..1] to RGB [0..1]
    vec3 rgb = HUEtoRGB(hsv.x);
    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;
}

vec3 HSLtoRGB(in vec3 hsl)
{
    // Hue-Saturation-Lightness [0..1] to RGB [0..1]
    vec3 rgb = HUEtoRGB(hsl.x);
    float c = (1. - abs(2. * hsl.z - 1.)) * hsl.y;
    return (rgb - 0.5) * c + hsl.z;
}
// end https://www.shadertoy.com/view/4dKcWK

void main() {
    vec2 st = only_work_with_central_square(vec2(ts.x, ts.y));
    st.y = -st.y;
    st = rotate2d(-PIH) * st;

    const float pi = 3.14159265359;
    const float tau = 2.0 * pi;
    const float phi = 1.6180339887;

    float lambda;
    float fadeout;
    float arms;

    vec2 polar = d_and_theta(st);
    float d = polar.x;
    float theta = polar.y;
    float shift;

    int ring = int(min(d, 1.0) * u_rings);
    d = fract(min(d, 1.0) * u_rings);

    float short_wave;
    float long_wave;

    if (ring == 0) {
        lambda = 0.7;
        fadeout = 0.2;
        arms = 3.0;
        float shift = (theta / tau) * (lambda * arms);
        short_wave = (cos((tau / lambda) * (d - (u_time + shift))) + 1.0) / 2.0;
        long_wave = (sin(tau / (fadeout * ((cos(-u_time) + 2.0) / 2.0)) * d) + 1.0) / 2.0;
    } else if (ring == 1) {
        lambda = 0.6;
        fadeout = 0.4;
        arms = 5.0;
        float shift = (theta / tau) * (lambda * arms);
        short_wave = (cos((tau / lambda) * (d - (-u_time + shift))) + 1.0) / 2.0;
        long_wave = (sin(tau / (fadeout * ((cos(u_time) + 2.0) / 2.0)) * d) + 1.0) / 2.0;
    } else if (ring == 2) {
        lambda = 0.68;
        fadeout = 0.2;
        arms = 3.0;
        float shift = (theta / tau) * (lambda * arms);
        short_wave = (cos((tau / lambda) * (d - (u_time + shift))) + 1.0) / 2.0;
        long_wave = (sin(tau / (fadeout * ((cos(-u_time) + 2.0) / 2.0)) * d) + 1.0) / 2.0;
    } else {
        lambda = 0.68;
        fadeout = 0.5;
        arms = 3.0;
        float shift = (theta / tau) * (lambda * arms);
        short_wave = (cos((tau / lambda) * (d - (-u_time + shift))) + 1.0) / 2.0;
        long_wave = (sin(tau / (fadeout * ((cos(u_time) + 2.0) / 2.0)) * d) + 1.0) / 2.0;
        // short_wave = d;
        // long_wave = 1.0;
    }
    
    float a = max(short_wave * long_wave, 0.2);

    float h = 0.0;
    float s = a;
    float l = a * 0.98;

    if (ring == 3) {
        h = (theta + pi) / tau;
    } else if (ring == 2) {
        h = u_s_pct;
    } else if (ring == 1) {
        h = u_m_pct;
    } else if (ring == 0) {
        h = u_h_pct;
    }

    const float padding = 0.02;
    const float padding_transition = 0.28;
    l = (smoothstep(padding, padding + padding_transition, d) - smoothstep(1.0 - (padding + padding_transition), 1.0 - padding, d)) * l;

    vec3 outRgb = HSLtoRGB(vec3(h, s, l));

    outColor = vec4(outRgb, 1);
}
`;

// https://webgl2fundamentals.org/webgl/lessons/webgl-fundamentals.html
function createShader(gl, type, source) {
  let shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (success) {
    return shader;
  }

  console.log(gl.getShaderInfoLog(shader));  // eslint-disable-line
  gl.deleteShader(shader);
  return undefined;
}

// https://webgl2fundamentals.org/webgl/lessons/webgl-fundamentals.html
function createProgram(gl, vertexShader, fragmentShader) {
  let program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  let success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (success) {
    return program;
  }

  console.log(gl.getProgramInfoLog(program));  // eslint-disable-line
  gl.deleteProgram(program);
  return undefined;
}

function resize(canvas) {
  // Lookup the size the browser is displaying the canvas.
  let displayWidth  = canvas.clientWidth;
  let displayHeight = canvas.clientHeight;

  // Check if the canvas is not the same size.
  if (canvas.width  !== displayWidth ||
      canvas.height !== displayHeight) {

    // Make the canvas the same size
    canvas.width  = displayWidth;
    canvas.height = displayHeight;
  }
}

main();
function main() {
  const canvas = document.querySelector("#glCanvas");
  const gl = canvas.getContext("webgl2");
  if (!gl) {
    alert("No WebGl2 for you =(");
    return;
  }
  gl.clearColor(1.0, 0.0, 0.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  // remaining webgl setup from https://webgl2fundamentals.org/webgl/lessons/webgl-fundamentals.html
  // create GLSL shaders, upload the GLSL source, compile the shaders
  let vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  let fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  // Link the two shaders into a program
  let program = createProgram(gl, vertexShader, fragmentShader);

  // look up where the vertex data needs to go.
  let positionAttributeLocation = gl.getAttribLocation(program, "a_position");

  // Create a buffer and put three 2d clip space points in it
  let positionBuffer = gl.createBuffer();

  // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

  let positions = [
    -1, -1,
    -1, 1,
    1, -1,
    1, -1,
    -1, 1,
    1, 1,
  ];
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

  // Create a vertex array object (attribute state)
  let vao = gl.createVertexArray();

  // and make it the one we're currently working with
  gl.bindVertexArray(vao);

  // Turn on the attribute
  gl.enableVertexAttribArray(positionAttributeLocation);

  // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
  let size = 2;          // 2 components per iteration
  let type = gl.FLOAT;   // the data is 32bit floats
  let normalize = false; // don't normalize the data
  let stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
  let offset = 0;        // start at the beginning of the buffer
  gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

  let t_loc = gl.getUniformLocation(program, "u_time");
  let resolution_loc = gl.getUniformLocation(program, "u_resolution");
  let h_pct_loc = gl.getUniformLocation(program, "u_h_pct");
  let m_pct_loc = gl.getUniformLocation(program, "u_m_pct");
  let s_pct_loc = gl.getUniformLocation(program, "u_s_pct");
  let rings_loc = gl.getUniformLocation(program, "u_rings");

  requestAnimationFrame(drawScene);

  function drawScene(t) {
    const now = new Date();
    resize(gl.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.useProgram(program);
    gl.bindVertexArray(vao);
    gl.uniform1f(t_loc, t / 10000);
    gl.uniform2f(resolution_loc, gl.canvas.width, gl.canvas.height);
    gl.uniform1f(h_pct_loc, now.getHours() / 24);
    gl.uniform1f(m_pct_loc, now.getMinutes() / 60);
    gl.uniform1f(s_pct_loc, now.getSeconds() / 60);
    gl.uniform1f(rings_loc, 4.0);

    // draw
    let primitiveType = gl.TRIANGLES;
    let offset = 0;
    let count = 6;
    gl.drawArrays(primitiveType, offset, count);

    requestAnimationFrame(drawScene);
  }
}
</script>
</html>
