<span class="aside"><a data-preview="/previews/bdf8d407010c2d41f3f438c55f60179beff233b612fe16dd75fedfa74db8d4a6.html" class="internal ref type" href="/braid-what\index.html#P">P</a> corresponds to the “patches” of braid, but without the purely intuitive notion of space or regions therein.</span>Let <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="enclosing normal_text type"><span class="enclosing" id="P"><span class="enclosing" data-preview="/previews/bdf8d407010c2d41f3f438c55f60179beff233b612fe16dd75fedfa74db8d4a6.html"><a href="/braid-what\index.html#P"><span class="mord text"><span class="mord">P</span></span></a></span></span></span></span></span></span> be a set of patches such that there exist<ul><li><span class="aside">Interestingly enough, this function need not be associative or commutative.</span>a binary function <dfn><a id="pp_to_p" data-preview="/previews/ed4c5f07be820ddd01e14b3693e8fb7332de4073f375541be3094a1ae1d5c1aa.html" class="internal fn" href="/braid-what\index.html#pp_to_p">pp_to_p</a></dfn> that maps any two patches to another patch,</li><li><span class="aside">This is a three-way merge.</span>a ternary function <dfn><a id="ppp_to_p" data-preview="/previews/5d8230b2168a3f95def83ec813337391e384ae98326c67c5a4c0d7515b584bde.html" class="internal fn" href="/braid-what\index.html#ppp_to_p">ppp_to_p</a></dfn> that maps any three patches to another patch, such that permuting the first and second argument does not change the result,</li><li><span class="aside">We need this to reduce any braid to a single value. If the three-way merges do not need to distinguish between the ordering of their arguments, and if <a data-preview="/previews/ed4c5f07be820ddd01e14b3693e8fb7332de4073f375541be3094a1ae1d5c1aa.html" class="internal ref fn" href="/braid-what\index.html#pp_to_p">pp_to_p</a> can be restricted to being associative and commutative, then both <a data-preview="/previews/5d8230b2168a3f95def83ec813337391e384ae98326c67c5a4c0d7515b584bde.html" class="internal ref fn" href="/braid-what\index.html#ppp_to_p">ppp_to_p</a> and <a data-preview="/previews/1211beed791bb0fc986626b101d9bcfda1ceda05c04ba31cc384ea2a4b65beef.html" class="internal ref fn" href="/braid-what\index.html#many_ps_to_p">many_ps_to_p</a> can be removed. I kept the more general version because I was not sure whether braid wants to break symmetry occasionally. If I was designing from scratch, I'd probably require only a single, binary, associative, and commutative function.</span>a function <dfn><a id="many_ps_to_p" data-preview="/previews/1211beed791bb0fc986626b101d9bcfda1ceda05c04ba31cc384ea2a4b65beef.html" class="internal fn" href="/braid-what\index.html#many_ps_to_p">many_ps_to_p</a></dfn> that maps any non-empty set of patches to another patch, and</li><li>a function <dfn><a id="p_to_d" data-preview="/previews/fc5598a7c3263be8f63ff27e586d245b72c4860110557ffeacce6756797a5524.html" class="internal fn defined_here" href="/braid-what\index.html#p_to_d">p_to_d</a></dfn> that maps a possibly complicated patch to a concrete domain value.</li></ul>