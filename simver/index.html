<!doctype html><html><head><meta charset="utf-8" /><title>Simple Versioning</title><link href="/assets/simver.css" rel="stylesheet" /><script src="/assets/anchorli.js"></script><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0" /><meta name="author" content="Aljoscha Meyer" /><meta name="description" content="Simple Versioning spec and website" /></head><body><div id="spec"><h1 id="sane-versioning-1">Simple Versioning</h1><h2 id="summary">Summary</h2><p>Given a version number NUMBER, increment the:</p><ol><li>NUMBER version when you make backward-compatible API changes.</li></ol><p style="margin-top: 1em;">Breaking changes result in a new package with new versioning.</p><h2 id="introduction">Introduction</h2><p>From the perspective of dependency management, a software package is solely defined by its API — typically in prose, sometimes backed by a type system. Dependency management cares about only one notion regarding such APIs: given an explicitly specified package <i>A</i>, can some package <i>B</i> — found through dependency resolution — be substituted for it? The answer is “yes” if and only if the API of <i>B</i> is compatible with that of <i>A</i> (where <i>compatibility</i> usually goes beyond what can be checked mechanically in a type system).</p><p>As a package evolves, the maintainers release a sequence of successively compatible versions. We propose to assign successive natural numbers to these releases, and call this system “Simple Versioning.”</p><p>What happens when a package needs a breaking change? You create a completely new package with independent versioning. For a dependency management system, <i>React version 2.0.0</i> and <i>React version 3.0.0</i> relate to each other in the exact same way as <i>React version 2.0.0</i> and <i>jQuery 2.0.0</i>. To humans, there is a meaningful difference between these two pairs, but this difference has nothing to do with dependency management. We clearly should not complicate computer systems based on irrational human needs.</p><h2 id="simple-versioning-specification-simver">Simple Versioning Specification (SimVer)</h2><p><s>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="https://tools.ietf.org/Html/rfc2119">RFC 2119</a>.</s></p><p>Everything is normative unless indicated otherwise, duh. This is a specification.</p><ol><li><p>There is no need to define <i>software package</i> or <i>version</i> in a specification for versioning software packages; everybody already knows the one universally agreed-upon meaning of these terms.</p></li><li><p>Software packages using Simple Versioning must declare a public API. <em>How</em> to do so is out of scope of this specification. Good luck.</p></li><li><p>Associated with every release of a package must be exactly one version <i>Number</i>, where <i>Number</i> is a natural number (possibly zero).</p></li><li><p>All package releases must happen in a linear order; the version numbers must correspond to that linear order.</p></li><li><p>For any two versions <i>Number</i> and <i>Number + 1</i> of the same package, any dependent on version <i>Number</i> must be able to substitute version <i>Number + 1</i> without changing... <i>something</i>? Clearly there will be observable changes on <em>some</em> level, since the versions are not equal. The exact notion of which changes are acceptable is out of scope of this specification, and should be communicated by the package authors. In advance, please.</p></li><li><p>For human reading or machine processing, encode a version number <i>Number</i> as an ASCII decimal number without leading zeros.</p></li></ol><h2 id="backusnaur-form-grammar-for-valid-simver-versions">Backus–Naur Form Grammar for Valid SimVer Versions</h2><pre><code>&lt;valid simver&gt; ::= "0" | &lt;positive digit&gt; | &lt;positive digit&gt; &lt;digits&gt;

&lt;digits&gt; ::= &lt;digit&gt; | &lt;digit&gt; &lt;digits&gt;

&lt;digit&gt; ::= "0" | &lt;positive digit&gt;

&lt;positive digit&gt; ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"</code></pre><h2 id="why-use-simple-versioning">Why Use Simple Versioning?</h2><p>This is not a new or revolutionary idea. In fact, you probably do something <a href="https://semver.org/#why-use-semantic-versioning">close to this</a> already. The problem is that “close” isn’t good enough. Without compliance to some sort of formal specification, version numbers are essentially useless for dependency management. By giving a name and clear definition to the above ideas, it becomes easy to communicate your intentions to the users of your software. Once these intentions are clear, flexible (but not too flexible) dependency specifications can finally be made.</p><p>A simple example will demonstrate how Simple Versioning can make dependency hell a thing of the past. Consider a library called “Firetruck.” It requires a Simply Versioned package named “Ladder.” At the time that Firetruck is created, Ladder is at version <i>3</i>. Since Firetruck uses some functionality that was first introduced in <i>3</i>, you can safely specify the Ladder dependency as greater than or equal to <i>3</i>. Now, when Ladder version <i>4</i> and <i>5</i> become available, you can release them to your package management system and know that they will be compatible with existing dependent software.</p><p>As a responsible developer you will, of course, want to verify that any package upgrades function as advertised. The real world is a messy place; there’s nothing we can do about that but be vigilant. What you can do is let Simple Versioning provide you with a sane way to release and upgrade packages without having to roll new versions of dependent packages, saving you time and hassle.</p><p>If all of this sounds desirable, all you need to do to start using Simple Versioning is to declare that you are doing so and then follow the rules. Link to this website from your README so others know the rules and can benefit from them.</p><h2 id="faq">FAQ</h2><h3 id="major-version-names">If breaking changes result in new packages, do I need to come up with a new name every time?</h3><p>Yes. Thankfully, we have come up with a simple and deterministic algorithm: If you need to do breaking changes to a package called <i>Flibble</i>, call the new package <i>Flibble 2</i>, the one after that <i>Flibble 3</i>, and so on. This works great with existing package managers, and humans will just call the thing <i>Flibble</i> most of the time (while automatically becoming more precise when needed).</p><h3 id="discoverability">What about discoverability?</h3><p>You do not find out about breaking changes from your package manager, but through other channels such as a website or a code repository. Those same channels can also announce switches to completely new packages due to breaking changes. Clearly, there are absolutely no problems whatsoever with Simple Versioning.</p><h3 id="minor-vs-patch">Without a distinction between preview releases, bug fix releases, and feature releases, how will I select the correct policy for making all my users automatically and blindly download arbitrary code that any future maintainer of any of my (transitive) dependencies might ever publish?</h3><p>The same way you <a href="https://research.swtch.com/vgo-intro#minimal_version_selection">should</a> without Simple Versioning.</p><h3 id="embed">How can I use Simple Versioning in a world full of Semantic Versioning infrastructure?</h3><p>Semantic Versioning contains a subset which is isomorphic to Simple Versioning. To embed a Simple Version <i>Number</i> in a Semantic Versioning system, use the semantic version <i>0.Number.0</i>. This will work with all Semantic Versioning software, and the software will be none the wiser!</p><h3 id="is-there-a-suggested-regular-expression-regex-to-check-a-simver-string">Is there a suggested regular expression (RegEx) to check a SimVer string?</h3><p><code>0|[1-9]\d*</code></p><h3 id="ebnf-lol">Why did you make me read a 214-character BNF grammar when there is an equivalent 10-character RegEx?</h3><p>Because a “specification” without a BNF grammar is too informal to be called a specification.</p><h3 id="concurrency">Sequential version numbering makes concurrent package updates by independent maintainers impossible, because they would assign the same version number to different programs. This precludes truly decentralised, eventually-consistent, delay-tolerant software publishing, thus implicitly entrenching a status quo that assumes complete sovereignty over software packages by a single, privileged author (or group of authors who together act as a single logical author). How dare you?</h3><p>Well, nobody else seems to care about this either.</p><p>But, since you did just ask, I will lay out some ideas. Instead of using successive numbers as version identifiers, you could identify each version by a secure hash. This hash should be both over the data of the version in question and over the version identifier (i.e., the hash) of the previous version, if any. This results in a linked list of hashes. (If you absolutely insist, you can also hash in some data to distinguish, for example, between patch releases and feature releases.)</p><p>More accurately, this scheme results in a <em>tree</em> of hashes: different versions of a package can branch off at the same base version. This is great, because it enables concurrent creation of new versions without requiring a consensus mechanism between all package authors for naming them.</p><p>A typical follow-up question to this kind of design is how to merge together concurrently published versions which both have features to keep. There is an answer which is as obviously correct and simple as it is boring: add the combined features on one of the concurrent branches, and abandon the other one. Nothing in this system benefits from complicating the underlying data structures and cryptography by adding merge operators.</p><p>A tree of versions results in a new challenge: given two versions, how do you efficiently determine whether one of them is a predecessor of the other? Systems such as <a href="https://worm-blossom.github.io/reed/">Reed</a> allow querying the happened-before relation on a tree in logarithmic time, while adding only a constant amount of additional data to incorporate into each version hash. In a peer-to-peer setting where participants might not want to store full version histories, peers can perform these comparisons while storing only logarithmically-sized subsets of the version histories.</p><p>Such a system of tree-shaped version histories ultimately erodes the notion of coherent package identities: anyone can fork off of any published version and create their own compatible derivatives. Those might be malicious, or shoddy, but this is not problematic, since there can be no automatic fetching and installation of the newest compatible version anyway (because there <em>is</em> no single newest compatible version).</p><p>You <em>can</em> of course establish channels where trusted maintainers can publish their “official” updates, thus restoring the notion of package identities (and linear version histories). In high-trust environments, you could even subscribe to such channels and automatically resolve to the most recent version. To keep things decentralised, delay-tolerant, and eventually consistent, I would recommend using <a href="https://aljoscha-meyer.de/posts/mutability_and_rot/index.html#mutability_and_rot_signed_bindings">signed bindings</a> as the mechanism for assigning a single name to a continuously updating package identity.</p><p>This would be a design for a package manager that is <em>actually</em> decentralised, not one that simply relies on centralised package authorship and places the data on content-addressed peer-to-peer storage. But, you know, this is just an FAQ entry inside a specification of questionable quality, so probably not worth taking seriously.</p><h2 id="about">About</h2><p>The Simple Versioning specification was originally authored by <a href="https://aljoscha-meyer.de/">Aljoscha Meyer</a>, a good-for-nothing who didn’t co-found anything.</p><p>If you’d like to leave feedback, feel free to reach out somehow. If that is too much effort, instead hug a person who loves you. Or plant a tree, or something.</p><p>Yes, I am aware of <a href="https://simver.org/">simver.org</a>. I am even aware of the same author proposing <a href="https://mastodon.online/@JayBazuzi/113693758584148399">integral versioning</a> as well. What is more shocking — the fact that these dazzling ideas (and naming choices) should be rediscovered independently, the fact that I deliberately withheld this prior work for dramatic effect, or the fact that Snape kills Dumbledore?</p><h2 id="license">License</h2><p><a href="https://Creativecommons.org/Licenses/by/4.0/">Creative Commons ― CC BY 4.0</a></p><p>This page was adapted from the <a href="https://semver.org">Semver 2.0.0</a> page, released under <a href="https://Creativecommons.org/Licenses/by/3.0/">Creative Commons ― CC BY 3.0</a>.</p></div></body></html>