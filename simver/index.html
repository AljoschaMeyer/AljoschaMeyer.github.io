<!doctype html><html><head><meta charset="utf-8" /><title>Simple Versioning</title><link href="/assets/simver.css" rel="stylesheet" /><script src="/assets/anchorli.js"></script><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0" /><meta name="author" content="Aljoscha Meyer" /><meta name="description" content="Simple Versioning spec and website" /></head><body><div id="spec"><h1 id="sane-versioning-1">Simple Versioning</h1><h2 id="summary">Summary</h2><p>Given a version number NUMBER, increment the:</p><ol><li>NUMBER version when you make backward-compatible API changes.</li></ol><p style="margin-top: 1em;">Breaking changes result in a new package with new versioning.</p><h2 id="introduction">Introduction</h2><p>In the world of software management there exists a dreaded notion called “<a href="https://Semver.org/#spec-item-8">major version updates</a>.” A software package breaks its API, and signals this by incrementing part of its version number. This pattern projects a human need for conceptual continuity onto a computer system. But computers have no corresponding notion of continuity.</p><p>From the perspective of dependency management, a software package is solely defined by its API — typcially in prose, sometimes with some basic support by a type system. Dependency management cares about only one notion regarding such APIs: given an explicitly specified package <i>A</i>, can some package <i>B</i> — found through dependency resolution — be substituted for it? The answer is “yes” if and only if the API of <i>B</i> is compatible with that of <i>A</i> (where compatibility typically goes beyond what is expressed in a type system).</p><p>As a package evolves, the maintainers release a sequence of successively compatible versions. We propose to assign successive natural numbers to these releases.</p><p>We call this system “Simple Versioning.” Under this scheme, version numbers and the way they change convey meaning about the underlying code and what has been modified from one version to the next.</p><p>What happens when a package needs a breaking change? You create a completely new package with independent versioning. For a dependency management system, <i>React version 2.0.0</i> and <i>React version 3.0.0</i> relate to each other in the exact same way as <i>React version 2.0.0</i> and <i>jQuery 2.0.0</i>. There is of course a meaningful difference between these two pairs, but this difference should have nothing to do with dependency management.</p><h2 id="simple-versioning-specification-simver">Simple Versioning Specification (SimVer)</h2><p><s>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="https://tools.ietf.org/Html/rfc2119">RFC 2119</a>.</s></p><p>Everything is normative unless indicated otherwise, duh. This is a specification.</p><ol><li><p>There is clearly no need to define <i>software package</i> or <i>version</i> in a specification for versioning software packages, because everybody already knows the one universally agreed-upon meaning of these terms.</p></li><li><p>Software packages using Simple Versioning must declare a public API. How this is done is out of scope of this specification. Good luck.</p></li><li><p>Associated with every release of a package must be exactly one version <i>Number</i>, where <i>Number</i> is a natural number (possibly zero).</p></li><li><p>All package releases must happen in a linear order; the version numbers must correspond to that linear order.</p></li><li><p>For any two versions <i>Number</i> and <i>Number + 1</i> of the same package, any dependent on version <i>Number</i> must be able to substitute version <i>Number + 1</i> without changing... <i>something</i>? Clearly there will be observable changes on <em>some</em> level, since the versions are not equal. The exact notion of which changes are acceptable is out of scope of this specification, and should be communicated by the package authors. In advance, please.</p></li><li><p>For human reading or machine processing, encode a version number <i>Number</i> as an ASCII decimal number without leading zeros.</p></li></ol><h2 id="backusnaur-form-grammar-for-valid-simver-versions">Backus–Naur Form Grammar for Valid SimVer Versions</h2><pre><code>&lt;valid simver&gt; ::= "0" | &lt;positive digit&gt; | &lt;positive digit&gt; &lt;digits&gt;

&lt;digits&gt; ::= &lt;digit&gt; | &lt;digit&gt; &lt;digits&gt;

&lt;digit&gt; ::= "0" | &lt;positive digit&gt;

&lt;positive digit&gt; ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"</code></pre><h2 id="why-use-simple-versioning">Why Use Simple Versioning?</h2><p>This is not a new or revolutionary idea. In fact, you probably do something <a href="https://semver.org/#why-use-semantic-versioning">close to this</a> already. The problem is that “close” isn’t good enough. Without compliance to some sort of formal specification, version numbers are essentially useless for dependency management. By giving a name and clear definition to the above ideas, it becomes easy to communicate your intentions to the users of your software. Once these intentions are clear, flexible (but not too flexible) dependency specifications can finally be made.</p><p>A simple example will demonstrate how Simple Versioning can make dependency hell a thing of the past. Consider a library called “Firetruck.” It requires a Simply Versioned package named “Ladder.” At the time that Firetruck is created, Ladder is at version <i>3</i>. Since Firetruck uses some functionality that was first introduced in <i>3</i>, you can safely specify the Ladder dependency as greater than or equal to <i>3</i>. Now, when Ladder version <i>4</i> and <i>5</i> become available, you can release them to your package management system and know that they will be compatible with existing dependent software.</p><p>As a responsible developer you will, of course, want to verify that any package upgrades function as advertised. The real world is a messy place; there’s nothing we can do about that but be vigilant. What you can do is let Simple Versioning provide you with a sane way to release and upgrade packages without having to roll new versions of dependent packages, saving you time and hassle.</p><p>If all of this sounds desirable, all you need to do to start using Simple Versioning is to declare that you are doing so and then follow the rules. Link to this website from your README so others know the rules and can benefit from them.</p><h2 id="faq">FAQ</h2><h3 id="major-version-names">If breaking changes result in new packages, do I need to come up with a new name every time?</h3><p>Yes. Thankfully, we have come up with a simple and deterministic algorithm: If you need to do breaking changes to a package called <i>Flibble</i>, call the new package <i>Flibble 2</i>, the one after that <i>Flibble 3</i>, and so on. This works great with existing package managers, and humans will just call the thing <i>Flibble</i> the whole time (automatically becoming more precise when needed).</p><h3 id="minor-vs-patch">Without a distinction between preview releases, bug fix releases, and feature releases, how will I select the correct policy for making all my users automatically and blindly download arbitrary code that any future maintainer of any of my (transitive) dependencies might ever publish?</h3><p>The same way you <a href="https://research.swtch.com/vgo-intro#minimal_version_selection">should</a> without Simple Versioning.</p><h3 id="is-there-a-suggested-regular-expression-regex-to-check-a-simver-string">Is there a suggested regular expression (RegEx) to check a SimVer string?</h3><p><code>0|[1-9]\d*</code></p><h3 id="embed">How can I use Simple Versioning in a world full of Semantic Versioning infrastructure?</h3><p>Semantic Versioning contains a subset which is isomorphic to Simple Versioning. To embed a Simple Version <i>Number</i> in a Semantic Versioning system, use the semantic version <i>0.Number.0</i>. This will work for all software using Semantic Versioning, the software will be none the wiser!</p><h3 id="concurrency">Sequential version numbering makes concurrent package updates by independent maintainers impossible, because they would assign the same version. This precludes truly decentralised, eventually-consistent, delay-tolerant software publishing, thus implicitly entrenching a status quo that assumes complete sovereignty over software packages by a single, privileged author (or group of authors who together act as a single logical author). How dare you?</h3><p>Well, nobody else seems to care about this either.</p><p>But since you just asked, I will lay out some ideas. Instead of using successive numbers as version identifiers, you could identify versions by a secure hash. This hash should be both over the data of the version in question and over the version identifier (i.e., the hash) of the previous version, if any. This results in a linked list of hashes. (If you absolutely insist, you can also hash in some data to distinguish, for example, between patch releases and feature releases.)</p><p>More precisely, this scheme results in a <em>tree</em> of hashes: different versions of a package might branch off at the same base version. This is great, because it enables concurrent creation of new versions, and thus eliminates the need for a consensus mechanism between package authors.</p><p>A typical follow-up question to this kind of design is how to merge together concurrently published versions that both have features that should be kept. There is an answer which is as obviously correct and simple as it is boring: add the combined features on one of the concurrent branches, and abandon the other one. Nothing in this system benefits from complicating the underlying data structures and cryptography by adding merge operators.</p><p>A tree of versions results in a new challenge: given two versions, how do you efficiently determine whether one of them is a predecessor of the other? Systems such as <a href="https://worm-blossom.github.io/reed/">Reed</a> allow determining this in logarithmic time, while adding only a constant amount of additional data to incorporate into each version hash. Even in a peer-to-peer setting where participants might not want to store full version histories, peers can enable these comparisons by storing only a logarithmically-sized subset of the version histories.</p><p>Such a system of tree-shaped version histories ultimately erodes the notion of coherent package identities: anyone can fork off of any published version and create their own compatible derivatives. Those might be malicious, or shoddy, but this is not problematic, since there can be no automatic fetching and installation of the newest compatible version anyway (because there <em>is</em> no single newest compatible version).</p><p>You <em>can</em> of course establish channels where trusted maintainers can publish their “official” updates, thus restoring the notion of package identities (and linear version histories). In high-trust environments, you could even subscribe to such channels and automatically resolve to the most recent version. To keep things decentralised, delay-tolerant, and eventually consistent, I would recommend using <a href="https://aljoscha-meyer.de/posts/mutability_and_rot/index.html#mutability_and_rot_signed_bindings">signed bindings</a> as the mechanism for assigning a single name to a continuously updating package identity.</p><p>This would be a design for a package manager that is <em>actually</em> decentralised, not one that simply relies on centralised package authorship and places the data on content-addressed peer-to-peer storage. But, you know, this is just an FAQ entry inside a specification of questionable seriousness, so probably not worth taking seriously.</p><h2 id="about">About</h2><p>The Simple Versioning specification was originally authored by <a href="https://aljoscha-meyer.de/">Aljoscha Meyer</a>, a good-for-nothing who didn’t co-found anything.</p><p>If you’d like to leave feedback, feel free to reach out somehow. If that is too much effort, instead hug a person who loves you. Or plant a tree, or something.</p><h2 id="license">License</h2><p><a href="https://Creativecommons.org/Licenses/by/4.0/">Creative Commons ― CC BY 4.0</a></p><p>This page was adapted from the <a href="https://semver.org">Semver 2.0.0</a> page, released under <a href="https://Creativecommons.org/Licenses/by/3.0/">Creative Commons ― CC BY 3.0</a>.</p></div></body></html>